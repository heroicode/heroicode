<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JBake</title>
    <link>https://nathansgreen.github.io</link>
    <atom:link href="https://nathansgreen.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <description>JBake Bootstrap Template</description>
    <language>en-gb</language>
    <pubDate>Tue, 23 May 2017 11:47:32 -0500</pubDate>
    <lastBuildDate>Tue, 23 May 2017 11:47:32 -0500</lastBuildDate>

    <item>
      <title>Unit Tests as Experiments</title>
      <link>https://nathansgreen.github.io/blog/2017/unit-tests-as-experiments.html</link>
      <pubDate>Thu, 11 May 2017 00:00:00 -0500</pubDate>
      <guid isPermaLink="false">blog/2017/unit-tests-as-experiments.html</guid>
      	<description>
	&lt;p&gt;One of the strategies I&amp;rsquo;ve been using lately is creating unit tests when I have a problem that I don&amp;rsquo;t understand fully. It&amp;rsquo;s an easy way to encode a set of assumptions (test fixture setup), try out potential ways of solving a problem, then check whether it worked (assert some expected outcome).&lt;/p&gt;
&lt;p&gt;Since I often work without a REPL (Java 9 will change this), I need easy ways to run programs that are small and malleable. I also work with complex runtimes (magical, auto-configured Spring systems are one of many examples) and it helps to be able to simulate a complex system by setting up test fixtures that manage that complexity while providing direct access to the thing I need to test.&lt;/p&gt;
&lt;p&gt;I find this approach is also helpful when trying to work with an unfamiliar API. Sometimes my mental model of an API&amp;rsquo;s behavior doesn&amp;rsquo;t quite match reality, and a test is usually a quick way to verify an hypothesis about what outcomes I should expect.&lt;/p&gt;
&lt;p&gt;The BDD way of structuring tests fits this approach pretty well. Given some initial conditions, when this thing occurs, then I expect this outcome. The difference is that instead of encoding requirements, I&amp;rsquo;m encoding hypotheses.&lt;/p&gt;
	</description>
    </item>
    <item>
      <title>Role-based thinking – an experiment</title>
      <link>https://nathansgreen.github.io/blog/2014/role-based-thinking.html</link>
      <pubDate>Wed, 12 Nov 2014 00:00:00 -0600</pubDate>
      <guid isPermaLink="false">blog/2014/role-based-thinking.html</guid>
      	<description>
	&lt;p&gt;I have &lt;a href=&quot;/blog/2010/dns-aliasing.html&quot;&gt;previously written&lt;/a&gt; about the importance of thinking in terms of functional behavior rather than merely in terms of capability. That is, why we are doing something is at least as important as how we are doing it. Now, maybe I’ve been overdoing the whole Scrum thing lately (not likely), but I’ve started thinking more in terms of roles when I formulate tasks for my team. My old way of thinking (which I still frequently fall back into) goes something like this:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;We have a lot of technical debt. We need to remove unused dependencies from our build. We need to improve our test coverage. We need to improve our release process. We need to be able to onboard new team members more easily. We need a more robust continuous integration environment. We need to make troubleshooting easier for production support. We need to fully externalize our application configuration. We need to minimize the impact of poor change management on the part of our upstream dependencies….&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;There’s nothing wrong with working through a task list such as this, but it does have shortcomings. First, it (often) leads us to prioritize personal preference over team productivity. When each team member pursues these types of activities in isolation, the outcome is not always generalizable and so the impact is dampened.&lt;/p&gt;
&lt;p&gt;Second, it is difficult to justify these activities from a business perspective. The way I formulated the descriptions, there are no real quantifiable outcomes. While the objectives all sound good, we have to ask, what is the opportunity cost here? What are the tangible benefits to the team members who aren’t engineers? What are the benefits to the stakeholder the team is trying to serve?&lt;/p&gt;
&lt;p&gt;Finally, these sorts of to-do lists are often very difficult to estimate against. How do we know when is a task done? Which parts of the task have highest priority? The answer, typically, is when the person who completes the task is happy with the result. That’s not very well-structured, and in fact it smells like an anti-pattern. (Like when engineers write acceptance tests. But I digress.)&lt;/p&gt;
&lt;p&gt;So, my experiment, (which is ongoing, so I don’t have outcomes to report), is to take the concept of a user story and extend it to the various functional roles within our team. So there will be “role stories” but they can be formulated as typical user stories, and I will refer to them as user stories throughout. This concept is actually not unusual, or shouldn’t be, but I’ve only seen hints of this thinking on teams that I’ve worked with. I’m describing it here for my own benefit and because I assume many other teams out there fail to take a structured approach to self-organizing. (Certainly true of most of the teams I have worked on.)&lt;/p&gt;
&lt;p&gt;So the first user stories from my example would belong to the build manager. &lt;em&gt;As a build manager I need to remove unused dependencies from our modules…&lt;/em&gt; etc. By formulating the tasks in this way, we can not only improve the quality of the product (which will benefit the stakeholder), we allow team members to have input into the tasks that they are assigned. It is a mechanism to address stressors and productivity inhibitors. This improves morale, and, done correctly, improves competence.&lt;/p&gt;
&lt;p&gt;The next story would be for the quality assurance role. It would go something like this: &lt;em&gt;as the quality assurance owner, I want to improve our test coverage so that defects raised by testers are reduced by at least 50%. Acceptance criteria will be branch coverage of 80% in the following problem modules: …&lt;/em&gt; Of course, if the testers continue to raise defects, the issue would need to be revisited. Presumably the team would agree that this story makes sense, and would be able to break it down into small tasks, which should always be done.&lt;/p&gt;
&lt;p&gt;The next problem, facilitating team growth, is one that has been a struggle for most teams I’ve worked on. For that reason, I tend to think that it’s a difficult problem to solve. It can often be decomposed into small tasks and the burden shared among multiple members of the team, which I see as an upside. As a team member, I want to assist new team members by reducing the time it takes them to begin being productive without impacting the delivery of the sprint backlog. I’ll know this is possible when we have an accurate deployment diagram, a project overview guide, and a workstation setup guide.&lt;/p&gt;
&lt;p&gt;Where this thought experiment starts to get interesting is when we think about maintaining the “product” of these user stories. (Something the product owner really should care about.) So when a backlog shows a story like, &lt;em&gt;as a product user I need to be able to search for widgets&lt;/em&gt;, we see that there are implied user stories (role stories!) that exist in parallel. That is, &lt;em&gt;as an engineer I need to create a Maven project that exposes an HTTP-based search API&lt;/em&gt;, and also, &lt;em&gt;as a build manager I need to add new projects into our continuous integration environment&lt;/em&gt;, and of course &lt;em&gt;as a test designer, I need to write functional tests against all HTTP-based services using &lt;a target=&quot;_blank&quot; href=&quot;http://www.soapui.org/&quot;&gt;SoapUI&lt;/a&gt;&lt;/em&gt;. (You do test your code, right?) So the interesting property of this thought experiment is the natural decomposability of user stories into tasks, and those tasks are themselves a sort of user story (role story, in my terminology). Add stories for a technical writer, deployment manager, and production support team and you’ve avoided a lot of technical debt.&lt;/p&gt;
&lt;p&gt;The other point that must be mentioned, thought it is obvious, is that the tasks associated with these stories may be completed by the same person. One person may perform multiple functional roles. For example, a tech lead may often function as an engineer, team growth facilitator, build manager, documentation maintainer, etc., possibly all within the same day.&lt;/p&gt;
&lt;p&gt;Functional decomposition, which is really all I’m talking about, helps to narrow the scope of a task in order to make it manageable. Whether we’re writing use cases, user stories, software, or documentation, functional decomposition is an important tool that is often ignored yet very valuable.&lt;/p&gt;
	</description>
    </item>
    <item>
      <title>DNS aliasing: panacea?</title>
      <link>https://nathansgreen.github.io/blog/2010/dns-aliasing.html</link>
      <pubDate>Fri, 18 Jun 2010 00:00:00 -0500</pubDate>
      <guid isPermaLink="false">blog/2010/dns-aliasing.html</guid>
      	<description>
	&lt;p&gt;One tool that seems to be underused, at least in most corporations I’ve worked at, is the trusty DNS alias (called a CNAME record). Pretty much everybody understood the value of using DNS names as opposed to IP addresses (with some minor, unmentionably dull exceptions) but it wasn’t until I was at Sprint that I saw use of aliases. Even at that, they were just beginning to make use of them, having built a great many interdependent systems without the use of aliases, which is, as we shall see, problematic for just about everyone. So, from here, I will assume that you, the reader, are not so poorly configured as to have servers directly addressing each other by IP address. If you do, fix that problem first; come back to this when you’re done.&lt;/p&gt;
&lt;p&gt;What happens when you build a number of multi-tier applications? You start to see a proliferation of interconnected servers, with applications, databases, services, etc. all communicating with each other. What’s the problem? Change. Change becomes very difficult. The reason is that as the number of systems grow, it becomes increasingly difficult to know exactly which servers each application depends on. In fact, addressing systems by a single host name is really no different than using IP addresses in a multi-tier scenario.&lt;/p&gt;
&lt;p&gt;Let’s try a hypothetical scenario. If I have a dozen database servers, say &lt;code&gt;db01 - db12&lt;/code&gt;, what happens when I want to build a new server and use it as a replacement for the existing &lt;code&gt;db-08&lt;/code&gt;? Well, in order to migrate existing applications, we will have to rename the existing &lt;code&gt;db08&lt;/code&gt; and name the new server &lt;code&gt;db08&lt;/code&gt;. This is a bad idea. The alternative, typical way is not much better: alter the configuration of every system that depends upon &lt;code&gt;db08&lt;/code&gt; to point to the new &lt;code&gt;db13&lt;/code&gt;. Particularly if configuration changes require restarts for your applications, you can see that downtime is more or less inevitable.&lt;/p&gt;
&lt;p&gt;Now, if you had chosen to do what I propose, which is to use DNS aliases, not only do you not suffer the problems I described, you also gain certain advantages. But I guess at this point I should digress with an example of a DNS aliasing scheme, so that the situation is clear. With aliasing, the goal is to name systems according to their business or application function. So if we have, say, a payroll application, we can use “payroll” as an alias for the server hosting payroll. Now certainly a database will be needed, so we might call it something like &lt;code&gt;payroll-oltp&lt;/code&gt;, and perhaps have a separate &lt;code&gt;payroll-olap&lt;/code&gt; for reporting purposes. We can also assume that this is a legacy system with a newly-built web front-end, which we can call &lt;code&gt;payroll-web&lt;/code&gt;. Now, it is quite possible that all four of these aliases could point to one and the same server: this does not matter for my hypothetical scenario. The point is, each application should have its own unique set of aliases.&lt;/p&gt;
&lt;p&gt;Now that we have our aliases set up, what happens if we decide our database is too slow? Well, assuming we can do real-time replication, we set that up and then simply alter the DNS alias to point to the new server, and (assuming no application restarts are necessary) things will continue to function as normal. Obviously I’m oversimplifying, but the point is that you have separated your application’s resource concerns from your physical hardware implementation. Your application’s configuration has been decoupled from your DNS configuration.&lt;/p&gt;
&lt;p&gt;I should also point out that clients (users) can also benefit from aliasing. If you have hundreds of users connecting to &lt;code&gt;http://swds19/&lt;/code&gt; to access an application and you decide to migrate it to &lt;code&gt;http://swdx30/&lt;/code&gt;, not only do you have to tell the users, they have to update any bookmarks they have. Any documentation containing this information, such as training materials, would also need to be changed. By using a well-thought-out alias, you protect yourself against change and avoid confusing and frustrating your users. Should you continue to use your standard naming convention to address each server? Absolutely. However, those types of names are for administrators, not for applications, and most certainly not for users. Under my proposed schema, every host should have a minimum of 2 names: a conventional name for sysadmins, and a meaningful alias for an application or its end users.&lt;/p&gt;
&lt;p&gt;By now you must be saying, aren’t there some drawbacks to this? Well, it does mean a little administrative overhead to manage the DNS records. It also means you have to actually think in order to choose good aliases. (Choosing bad ones may come back to haunt you.) Particularly if you have a robust development/QA lifecycle, there may be more administrative work, since you have many more systems to work with. Yes, there is some overhead with this strategy, but I think in most situations it will more than pay for itself over time.&lt;/p&gt;
&lt;p&gt;Remember: choose an alias based on the function the system is intended to perform. It is perfectly fine to have many aliases pointing to the same system. Going back to the database scenario, if we have 15 applications that all use the same database server, yes, that means we would have 15 DNS aliases. It also means we can move any of those 15 databases and the only hard work is dealing with the individual database in question. Change is inevitable, but it doesn’t always have to be painful. Changing CNAME records is pretty easy compared to most alternatives. It’s not a panacea, but it solves a lot of problems before they become problems.&lt;/p&gt;
	</description>
    </item>

  </channel> 
</rss>
